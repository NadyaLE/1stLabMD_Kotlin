"# 1stLabMD_Kotlin" 

1. Реализуйте метод, возвращающий true, если среди четырех его аргументов ровно два истинны (любые). Во всех остальных случаях метод должен возвращать false.
Сигнатура: public static boolean booleanExpression(boolean a, boolean b, boolean c, boolean d)

2. В Григорианском календаре год является високосным в двух случаях: либо он кратен 4, но при этом не кратен 100, либо кратен 400. Реализуйте метод, вычисляющий количество високосных лет с начала нашей эры (первого года) до заданного года включительно.
Сигнатура: public static int leapYearCount(int year)

3. Реализуйте метод flipBit, изменяющий значение одного бита заданного целого числа на противоположное. Данная задача актуальна, например, при работе с битовыми полями. Договоримся, что биты нумеруются от младшего (индекс 1) к старшему (индекс 32). 
Сигнатура: public static int flipBit(int value, int bitIndex)

4. Реализуйте метод, проверяющий, является ли заданное число по абсолютной величине степенью двойки.
Решать можно разными способами:
- воспользовавшись одним удобным статическим методом из класса java.lang.Integer;
- применив пару трюков из двоичной арифметики;
- написав решение "в лоб" с циклом и условными операторами.
Сигнатура: public static boolean isPowerOfTwo(int value)

5. Реализуйте метод, проверяющий, является ли заданная строка палиндромом. Палиндромом называется строка, которая читается одинаково слева направо и справа налево (в том числе пустая). При определении "палиндромности" строки должны учитываться только буквы и цифры. А пробелы, знаки препинания, а также регистр символов должны игнорироваться. 
Подсказки :
для удаления из строки всех символов, не являющихся буквами и цифрами, можно воспользоваться регулярным выражением "[^a-zA-Z0-9]"; найдите в классе String метод, выполняющий замену по регулярному выражению;
для перестановки символов строки в обратном порядке можно воспользоваться методом reverse(), который находится в классе StringBuilder;
в классе String есть методы для преобразования всей строки в верхний и нижний регистр.
Сигнатура: public static boolean isPalindrome(String text)

6. Реализуйте метод, вычисляющий факториал заданного натурального числа.
Факториал N вычисляется как 1*2*...*N.
Поскольку это очень быстро растущая функция, то даже для небольших N вместимости типов int и long очень скоро не хватит. Поэтому будем использовать BigInteger.
Сигнатура: public static BigInteger factorial(int value)

7. Реализуйте метод, сливающий два отсортированных по неубыванию массива чисел в один отсортированный в том же порядке массив. Массивы могут быть любой длины, в том числе нулевой.
Предполагается, что вы реализуете алгоритм слияния, имеющий линейную сложность: он будет идти по двум исходным массивам и сразу формировать отсортированный результирующий массив. Так, чтобы сортировка полученного массива при помощи Arrays.sort() уже не требовалась. Если на вход подаются массивы {0, 2, 2} и {1, 3}, то на выходе должен получиться массив {0, 1, 2, 2, 3}
Сигнатура: public static int[] mergeArrays(int[] a1, int[] a2)
